#!/usr/bin/env python
"""
Implemantation of a GUI for the DoE.
"""
# Import PyQt Widgets for PyQt5 version
import sys
from PyQt5.QtWidgets import QApplication, QMainWindow, QTableWidgetItem, QHeaderView
# Import pyqtSlot to connect sliders and DoubleSpinBox signals
from PyQt5.QtCore import pyqtSlot, Qt
# Import QIcon
from PyQt5.QtGui import QIcon
# Import Ui_MainWindow class from UiMainApp.py generated by uic module
from Uidoe import Ui_Design
# Import functions from numpy library for scientific simulation
from numpy import pi, linspace, meshgrid, sin
import numpy as np
# Import matplotlib.cm for the color map in our image of diffraction
import matplotlib.cm as cm
# Import design_of_experiments
import design_of_experiments as doe
# To add a key binding
# from functools import partial
# Import os
import os
# To evaluate mathematic expression in a safe manneer
from eval_math import evaluate

class MainApp(QMainWindow, Ui_Design):
    """
    MainApp class inherit from QMainWindow and from
    Ui_MainWindow class in UiMainApp module.
    """

    def __init__(self):
        """Constructor or the initializer"""
        QMainWindow.__init__(self)
        # It is imperative to call self.setupUi (self) for the interface to initialize.
        # This is defined in design.py file automatically
        self.setupUi(self)
        self.setWindowTitle("Design of Experiments - by Vincent STRAGIER")
        self.n_parameters.setValue(1)
        self.n_parameters.setMinimum(1)
        self.n_parameters.setMaximum(8)
        header = self.measure.horizontalHeader()
        header.setSectionResizeMode(0, QHeaderView.Stretch)
        header = self.tableWidget.horizontalHeader()
        header.setSectionResizeMode(0, QHeaderView.Stretch)
        self.tableWidget.setAlternatingRowColors(True)
        self.measure.setAlternatingRowColors(True)
        self.coefficients_tab.setAlternatingRowColors(True)
        # https://doc.qt.io/qt-5/qtabwidget.html#setTabEnabled
        self.tabWidget.setTabEnabled(1, False)
        self.tabWidget.setTabEnabled(2, False)
        self.tabWidget.setTabEnabled(3, False)
        self.y = list()
        # It sets up layout and widgets that are defined
        self.showMaximized()
        self.pushButton.setEnabled(False)
        self.pushButton.clicked.connect(self.reset_y)
        # Only generate the graphs one for each tab
        self.to_genrate = [True, True, True]
        self.gen_all = True 

    # Intercept the key events
    def keyPressEvent(self, e):
        # Close the program
        if e.key() == Qt.Key_Escape:
            self.close()

        # Maximize the window
        if e.key() == Qt.Key_F11:
            if self.isMaximized():
                self.showNormal()
            else:
                self.showMaximized()

    # Reset the table of measures (y)
    def reset_y(self):
        n = self.measure.rowCount()
        self.y = []

        for i in range(n):
            self.measure.setItem(i, 0, QTableWidgetItem(None))

    # DoubleSpinBox signals (updates the DoE table)
    @pyqtSlot("double")
    def on_n_parameters_valueChanged(self, value):
        # Generate the tabWidgets
        self.tableWidget.setRowCount(int(2**value))
        self.tableWidget.setColumnCount(int(value))
        self.measure.setRowCount(int(2**value))

        # Generate the coefficent labels
        labels = doe.gen_a_labels(n=int(value))
        self.coefficients_tab.setColumnCount(len(labels))
        self.coefficients_tab.setHorizontalHeaderLabels(labels, 12)
        self.measure.setHorizontalHeaderLabels(['$y$'], 12)

        # Prepare the header to be rendered with LaTeX
        header = []
        for i in range(int(value)):
            header.append("$x_" + str(i) + "$")

        # Render the header labels in LaTeX
        self.tableWidget.setHorizontalHeaderLabels(header, 12)

        # Fill the tabWidget with the design
        design = doe.gen_design(int(value))
        for index, element in np.ndenumerate(design):
            if element == -1:
                item = QTableWidgetItem('-')  # create the item

            elif element == 1:
                item = QTableWidgetItem('+')  # create the item

            item.setTextAlignment(Qt.AlignHCenter)  # change the alignment
            self.tableWidget.setItem(index[0], index[1], item)
        
        """
        for x in range(2**int(value)):
            for y in range(int(value)):
                if design[x, y] == -1:
                    item = QTableWidgetItem('-')  # create the item

                elif design[x, y] == 1:
                    item = QTableWidgetItem('+')  # create the item

                item.setTextAlignment(Qt.AlignHCenter)  # change the alignment
                self.tableWidget.setItem(x, y, item)
        """

        self.on_measure_itemChanged(None) # Check if the table is full or not

    # Check the table containing the measures in order to generate the graphs if the table is full.
    @pyqtSlot(QTableWidgetItem)
    def on_measure_itemChanged(self, item):
        n = self.measure.rowCount()

        if(item != None): # Check if the value is convertible to a float if the item is not None (prevent circular call)
            try:
                # Evalutate the mathematic expression (https://realpython.com/python-eval-function/)
                result = float(evaluate(item.text()))

                if (item.text() != str(result)): # Update only when needed
                    self.measure.setItem(item.row(), item.column(), QTableWidgetItem(str(result)))

            except: # If the value is not convertible we empty the item and set it as None (the set trigger this function again)
                self.measure.setItem(item.row(), item.column(), None)

        self.y = []
        for i in range(n): # Read the measured values and check if the table is full
            if self.measure.item(i, 0) != None: # If the value exist, add it too the table
                self.y.append(float(self.measure.item(i, 0).text()))
            else: # If the item is empty (None) return, and set some states
                if len(self.y) == 0: # The table is empty so the reset button is disable
                    self.pushButton.setEnabled(False)
                else: # The table is not empty so the reset button is enable
                    self.pushButton.setEnabled(True)

                # Disable the tabs because there is not enough elements in the measurement tabWidget
                self.tabWidget.setTabEnabled(1, False)
                self.tabWidget.setTabEnabled(2, False)
                self.tabWidget.setTabEnabled(3, False)
                return

        # Enable the tabs (the measurement tabWidget is full)
        self.tabWidget.setTabEnabled(1, True)
        self.tabWidget.setTabEnabled(2, True)
        self.tabWidget.setTabEnabled(3, True)

        # Generate the table of coefficient
        coef = np.dot(doe.gen_X_hat(
            n=int(np.log2(len(self.y)))), np.array(self.y))
        labels = doe.gen_a_labels(n=int(np.log2(len(self.y))))

        # Display the coefficients (labels and values)
        self.coefficients_tab.setRowCount(1)
        self.coefficients_tab.setColumnCount(len(labels))
        self.coefficients_tab.setHorizontalHeaderLabels(labels, 12) # Use the LaTeX renderer

        for i in range(len(labels)):
            try:
                item = QTableWidgetItem(str(coef[i]))
                item.setTextAlignment(Qt.AlignHCenter)  # change the alignment
                self.coefficients_tab.setItem(0, i, item)
            except:
                print("error")

        # If gen_all, all the graphs are generated one time after all the measurement have been entered
        if self.gen_all:
            doe.clear_draw(self.coef_fig.canvas)
            doe.draw_coefficents(self.coef_fig.canvas,
                                 coef, color="blue", title="")
            doe.clear_draw(self.pareto_fig.canvas)
            doe.draw_pareto(self.pareto_fig.canvas,
                            coef, color="blue", title="")
            doe.clear_draw(self.henry_fig.canvas)
            doe.draw_henry(self.henry_fig.canvas, coef,
                           empirical_cumulative_distribution="modified", color="blue", title="")
            return
        
        # Says if we have to regenerate the graphs when we will change for another tab
        self.to_genrate = [True, True, True]

    @pyqtSlot(int)
    def on_tabWidget_currentChanged(self, index):
        # https://doc.qt.io/qt-5/qtabwidget.html#currentChanged
        if self.gen_all:
            return

        if index == 1 and self.to_genrate[0]:
            # Generate the table of coefficient
            coef = np.dot(doe.gen_X_hat(
                n=int(np.log2(len(self.y)))), np.array(self.y))
            doe.clear_draw(self.coef_fig.canvas)
            doe.draw_coefficents(self.coef_fig.canvas,
                                 coef, color="blue", title="")
            self.to_genrate[0] = False

        elif index == 2 and self.to_genrate[1]:
            coef = np.dot(doe.gen_X_hat(
                n=int(np.log2(len(self.y)))), np.array(self.y))
            doe.clear_draw(self.pareto_fig.canvas)
            doe.draw_pareto(self.pareto_fig.canvas,
                            coef, color="blue", title="")
            self.to_genrate[1] = False

        elif index == 3 and self.to_genrate[2]:
            coef = np.dot(doe.gen_X_hat(
                n=int(np.log2(len(self.y)))), np.array(self.y))
            doe.clear_draw(self.henry_fig.canvas)
            doe.draw_henry(self.henry_fig.canvas, coef,
                           empirical_cumulative_distribution="modified", color="blue", title="")
            self.to_genrate[2] = False


if __name__ == "__main__":
    # For Windows set AppID to add an Icon in the taskbar
    # https://stackoverflow.com/questions/1551605/how-to-set-applications-taskbar-icon-in-windows-7
    if sys.platform == 'win32':
        import ctypes
        from ctypes import wintypes
        appid = u'vincent_stragier.umons.doe.v1.0.0'  # arbitrary string
        ctypes.windll.shell32.SetCurrentProcessExplicitAppUserModelID(appid)

        lpBuffer = wintypes.LPWSTR()
        AppUserModelID = ctypes.windll.shell32.GetCurrentProcessExplicitAppUserModelID
        AppUserModelID(ctypes.cast(ctypes.byref(lpBuffer), wintypes.LPWSTR))
        appid = lpBuffer.value
        ctypes.windll.kernel32.LocalFree(lpBuffer)
    
    app = QApplication(sys.argv)
    # Launch the main app.
    MyApplication = MainApp()
    MyApplication.show()  # Show the form
    icon_path = os.path.join(os.path.dirname(sys.argv[0]), 'ico', 'fpms.svg')
    app.setWindowIcon(QIcon(icon_path))
    MyApplication.setWindowIcon(QIcon(icon_path))
    sys.exit(app.exec_())  # Execute the app
